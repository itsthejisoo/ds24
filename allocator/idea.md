### 1.	자료구조 탐색
-	배열
배열을 사용하면 삽입, 삭제에서 O(n)이 걸리고 탐색에는 O(1)이 걸린다. 따라서 할당할 때에는 O(n)이 걸릴 것으로 예상된다. 반면에, 탐색에는 O(1)이 걸리므로 메모리 할당을 해제할 때에는 O(1)이 걸릴 것으로 예상된다.
-	연결리스트
삽입, 삭제에서 O(1)이 걸리고 탐색에서는 O(n)이 걸린다. 연결 리스트을 사용하게 되면chunk의 크기는 정해져있지만, 노드의 크기를 동적으로 조정할 수 있다는 장점이 있다. 하지만 free할 때, id를 조회하는데 O(n)이 걸릴 것으로 생각된다. 시간복잡도에는 영향을 안 끼치지만, 포인터 오버헤드도 있다.
-	균형이진트리
삽입, 삭제, 탐색의 시간복잡도가 O(logn)으로 보장되어있다는 최고의 장점이 있다. 하지만 input.txt에서는 chunk의 개수가 2개가 최대인 것으로 확인했는데 만약에 훨씬 더 큰 메모리를 할당하게 되었을 때 chunk 개수가 많아지면 트리 노드의 정보를 저장하기 위해서 컴퓨터에서 더 많은 메모리를 차지하게 된다. 또한, 탐색 시간도 길어진다. 또한, input.txt 청크 최대 개수가 2개인데 청크를 균형이진트리 형식으로 연결한다하면 결국엔 연결리스트가 될 것이다.
-	해시 테이블
삽입, 삭제, 탐색에서 시간복잡도가 O(1)인데 청크가 2개 이상인 경우 여러 개의 청크를 하나의 해시(id)에 넣기 위해서 연결리스트 혹은 트리가 필요한데 연결리스트일 경우 O(n)이 걸린다. 균형 이진 트리일 경우 O(logn)이 걸린다. 할당 요청이 많지 않은 경우 해시 테이블의 공간 활용 효율성이 떨어진다(메모리 오버헤드).
-	체인 해시 테이블
삽입, 삭제, 탐색에서 O(1)이라는 최고의 시간 복잡도를 가지고 있다. 동적 할당 가능하고 요청한 크기만큼의 메모리를 할당할 수 있어서 메모리 공간을 효율적으로 쓸 수 있다. 그리고 해시 테이블과 비슷하나 충돌을 피할 수 있다. 하지만 input.txt를 확인해본 결과, 중복된 id값을 할당 혹은 해제를 요청하진 않는다. 따라서 충돌이 일어날 경우는 없어보인다. 그리고 포인터 오버헤드나 메모리 오버헤드의 위험이 있다.
### 2.	사용해본 자료구조
#### 1)	처음에 생각해본 알고리즘: 해시테이블 – 연결리스트
-	malloc 함수
: 한 id에 청크가 무조건 1개가 아니므로 연결리스트로 같은 식별번호끼리 연결해줘야 함. → 연결리스트 필수
(input.txt 한에서는 malloc은 O(1) 시간이 걸림. 메모리 안의 비어있는 청크를 탐색하지 않아도 되기 때문. )
-	해시 테이블은 삽입, 삭제, id 탐색할 때 시간 복잡도가 O(1)이므로 좋은 성능을 보인다. 하지만 연결리스트를 사용한 이상 어쩔 수 없이 탐색에서 O(n) 시간이 소요된다.
-	Free 함수
: 탐색에서 O(n)이 걸리므로 청크가 비어있는 노드가 될 때까지 할당된 청크를 탐색해야하므로 O(n)의 시간복잡도가 걸린다.

#### 2)	두번째로 생각해본 알고리즘: 딕셔너리 – 리스트
딕셔너리로 메모리를 할당하고, chunk가 두 개 이상일 경우에 리스트로 할당
-	malloc 함수
: chunk가 여러 개일 경우 할당할때 리스트에 chunk의 개수만큼 삽입해야하므로 O(n)이 걸림 → input.txt 한에서 Hash table -연결리스트가 성능이 더 좋음
-	free 함수
: 키 존재 여부를 확인하고 삭제하는데 O(1)의 시간이 걸림
→ Hash table -연결리스트보다 성능이 좋아보임
-	input.txt한에서는 hash table은 malloc이 O(1)이고 free 함수는 O(n)이므로 메모리 할당할 때는 hash table를 사용한 코드를 사용하는 것이 더 성능이 좋아 보인다. free 함수의 시간복잡도는 딕셔너리, 리스트를 사용한 코드가 hash table(배열-연결리스트)보다 더 좋으므로 메모리 할당 해제할 때는 딕셔너리-리스트 코드가 성능이 좋아 보인다.
-	하지만 딕셔너리는 삭제가 되면 없는 공간이기 때문에 사용된 chunk인지 사용하지 않은 공간인지 알아야하기 때문에 사용하기에는 적절하지 않아 보인다.


