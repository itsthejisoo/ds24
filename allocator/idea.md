## 해시테이블을 사용하여 allocator를 구현한 이유


### 배열
- 장점<br>
  - free할 메모리 id를 조회하는데 O(1) 시간이 걸린다.
- 단점<br>
    - 삽입과 삭제 모두 시간복잡도가 O(n)이다.


### 연결리스트
- 장점<br>
    - 삽입과 삭제 모두 시간복잡도가 O(1)이다.<br>
    - chunk의 크기는 정해져있지만, 노드의 크기를 동적으로 조정할 수 있다. -> 사용 중인 메모리 크기 계산하기 수월
- 단점<br>
    - free할 메모리 id를 조회하는데 O(n)의 시간이 걸린다.<br>
    - 포인터 오버헤드가 있다.


### 이진트리
- 장점<br>
    - 탐색의 시간복잡도가 O(logn)이다.<br>
    - 메모리 풀의 크기가 커져서 효율적
- 단점<br>
    - 트리의 균형을 유지하기 위해서 복잡해진다.

### 해시테이블
- 장점<br>
    - 메모리 할당, 해제에서 시간 복잡도 O(1)이다.
- 단점<br>
    - 할당 요청이 많지 않은 경우 해시 테이블의 공간 활용 효율성이 떨어진다. - 메모리 오버헤드

### chained 해시테이블
- 장점<br>
    - 삽입, 삭제, 탐색이 평균적으로 O(1)의 시간복잡도를 지닌다.
    - 동적 할당 가능하고 요청한 크기만큼의 메모리를 할당할 수 있어서 메모리 공간을 효율적으로 쓸 수 있다.
- 단점<br>
    - 포인터 오버헤드
    - 사용하지 않는 메모리 공간 낭비